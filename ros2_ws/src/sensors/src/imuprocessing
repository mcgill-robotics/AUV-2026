import numpy as np

class PoolIMUProcessor:
    def __init__(self):
        # 1. Define Gravity in EARTH Frame (Global)
        # Gravity is a constant physical force on Earth, pointing DOWN (assuming Z is Up/Down in Global/Earth frame).
        self.gravity_vector_earth = np.array([0.0, 0.0, -9.81])
        
        # 2. Storage for the "Zero" alignment matrix
        # This matrix will convert: Global Frame -> Pool Frame
        self.global_to_pool_offset = None 

    def handle_zero_service_request(self):
        """
        TRIGGER: Called when you press the 'Zero' button (ROS Service).
        ACTION: Averages 50 samples to create a stable 'Pool Frame' reference.
        """
        # Constants
        NUM_SAMPLES = 50
        quaternion_accumulator = np.array([0.0, 0.0, 0.0, 0.0])

        # --- 1. Data Collection Loop ---
        for _ in range(NUM_SAMPLES):
            # Get live raw orientation (w, x, y, z)
            current_q = self.get_live_imu_quaternion()
            
            # Add to accumulator (simple vector addition for averaging)
            # Note: For small deviations this works well. 
            quaternion_accumulator += current_q
            
            # (In real code, add a tiny sleep here to get distinct samples)

        # --- 2. Compute Average ---
        # We must normalize the result to ensure it's a valid unit quaternion
        avg_quaternion = self.normalize_quaternion(quaternion_accumulator)

        # --- 3. Create Offset Matrix ---
        # Convert the average quaternion to a rotation matrix.
        # This represents: Rotation from Global -> Device (at the moment of zeroing)
        R_global_to_device_at_zero = self.quaternion_to_matrix(avg_quaternion)

        # Since we want the current heading to be "Zero" in the pool,
        # The rotation from Global -> Pool is the INVERSE of the current rotation.
        self.global_to_pool_offset = R_global_to_device_at_zero.transpose()

        return "Pool Frame Zeroed Successfully with 50-sample average"

    def process_imu_data(self, live_quaternion, live_accel_device):
        """
        LOOP: Called every time new IMU data arrives.
        ACTION: 
        1. Rotate Device Accel -> Earth Accel
        2. Remove Earth Gravity
        3. Rotate Earth Accel -> Pool Accel
        """
        # Safety Check
        if self.global_to_pool_offset is None:
            return [0, 0, 0]

        # --- STEP 1: DEVICE -> EARTH (GLOBAL) ---
        
        # Get rotation matrix: Global -> Device
        R_global_to_device = self.quaternion_to_matrix(live_quaternion)
        
        # We need Device -> Global (Inverse/Transpose)
        R_device_to_global = R_global_to_device.transpose()
        
        # Rotate raw accel into Earth Frame
        accel_earth_frame = np.dot(R_device_to_global, live_accel_device)

        # --- STEP 2: GRAVITY COMPENSATION (IN EARTH FRAME) ---
        
        # The sensor measures Specific Force (+9.81 Up).
        # We add Gravity Vector (-9.81 Down) to cancel it out.
        # Result: Pure motion in Earth Frame.
        accel_motion_earth = accel_earth_frame + self.gravity_vector_earth

        # --- STEP 3: EARTH -> POOL ---
        
        # Apply the offset matrix we calculated during zeroing.
        # Transforms: Earth Frame -> Pool Frame
        accel_motion_pool = np.dot(self.global_to_pool_offset, accel_motion_earth)

        return accel_motion_pool

    # --- Helper Functions ---
    def normalize_quaternion(self, q):
        """
        HELPER: Ensures the quaternion is a unit quaternion (length 1).
        This is necessary after summing quaternions for the average.
        """
        norm = np.linalg.norm(q)
        if norm == 0: return q
        return q / norm

    def get_live_imu_quaternion(self):
        """
        HELPER: Placeholder for the ROS Subscriber call.
        In the real system, this reads the latest orientation from the IMU topic.
        """
        pass

    def quaternion_to_matrix(self, q):
        """
        HELPER: Placeholder for the mathematical conversion library.
        Converts the (w, x, y, z) quaternion vector into a 3x3 rotation matrix.
        """
        pass